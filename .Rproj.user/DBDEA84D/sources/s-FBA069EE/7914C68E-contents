#
# This is a Shiny web application. You can run the application by clicking
# the 'Run App' button above.
#
# Find out more about building applications with Shiny here:
#
#    http://shiny.rstudio.com/
#

library(shiny)

user <- Sys.getenv("USERPROFILE")
package <- paste(user, "\\Desktop\\CardioMVAR RAT version shiny\\CardioMVAR", sep ="")


if(!require(vars)){
  install.packages("vars")
}

if(!require(tseries)){
  install.packages("tseries")
}

if(!require(lmtest)){
  install.packages("lmtest")
}

if(!require(waveslim)){
  install.packages("waveslim")
}

require(vars)
require(tseries)
require(lmtest)
require(dplR)
devtools::load_all(package)



# Define UI for application that draws a histogram
ui <- fluidPage(
  tags$head(
   tags$style(HTML("
                  body {
                  background-color: moccasin;
                  color: black;
                  }
                  "))
   ),
  
  # Application title
  titlePanel("PhysioMVAR"),
  
  
  # Sidebar for data input
  wellPanel(
  fluidRow(
    column(3,
           wellPanel(h2("Upload data"),
                     p("Upload and store data from a specific subject",
                       style="text-align:justify;color:black;background-color:grey80"),
                     
                     uiOutput("data_file"),
                     tags$hr(),
                     radioButtons("separator", "Choose separator", choices = c(Semicolon =";",
                                                                               Comma = ",",
                                                                               Tab ="\t"), selected = ";"),
                     tags$hr(),
                     checkboxInput("Interpolate", "Interpolate Data", TRUE),
                     numericInput("int_freq", "Frequency", value = 20, width = 70),
                     actionButton("upload", "Confirm Upload")
           )
           
    ),
    column(9,
           wellPanel(style = "background:white",
             plotOutput("Raw", brush = "brush_raw", dblclick = "dbc_raw")
           ),
           br(),
           h5(textOutput("hr_stats")),
           h5(textOutput("sbp_stats"))
    )
    
  )
  ),
  wellPanel(
    h3("VAR model order:"),
    tags$hr(),
    checkboxInput("Use_order", "Use customed model order (otherwise the best model order will be used)", value = FALSE),
    numericInput("order", "Customed Model Order", value = 16, min = 1, max = 30, width = 70, step = 1), 
    br(),
    h3("Coherence settings:"),
    tags$hr(),
    checkboxInput("Use_coh", "Use coherence threshold to calculate estimates", value = FALSE),
    numericInput("coh_thr", "Coherence threshold", value = 0.5, min = 0, max = 1, width = 70, step = 0.05),
    br(),
    checkboxInput("surrogates", "Generate a distribution from surrogates from statistical analysis", value = FALSE),
    numericInput("gc_it", "Number of iterations for surrogate generation", value = 50, min = 1, width = 70, step = 1)
  ),
  wellPanel(
    h3("VAR model details from chosen segment:"),
    tags$hr(),
    h4(textOutput("text_timesegment")),
    h4(textOutput("text_stationary")),
    h4(textOutput("text_model")),
    h4(textOutput("text_model2")),
    h4(textOutput("text_whitenoise")),
    h4(textOutput("text_stable")),
    h4(textOutput("text_validity")),
    br(),
    actionButton("calculate", "Calculate Results"),
    textInput("name", "File name:", width = 300),
    downloadButton("download", "Download Calculated Results"),
    downloadButton("download2", "Download Model Structure")
  ),
  wellPanel(
            selectInput("input", "Select Input", choices = c("SBP", "RR"), "SBP"),
            selectInput("output", "Select Output", choices = c("SBP", "RR"), "RR"),
            selectInput("path_origin", "Select Origin for 0-Delay Transfer Path", choices = c("SBP", "RR"), "SBP"),
            br(),
            fluidRow(column(12,
              wellPanel(style = "height:850px;background:white",
                        imageOutput("CLDiagram"))
            )
            ),
            br(),
            h3("Spectral Coherence:"),
            wellPanel(style = "background:white",
                      plotOutput("coherence_plot")),
            br(),
            h3("Estimated transfer functions:"),
            tags$hr(),
            fluidRow(
              column(4,
                     h4("Closed-Loop Transfer Function:"),
            wellPanel(style = "background:white",
            plotOutput("noDEL")),
            h4(textOutput("HF1")),
            h4(textOutput("LF1")), 
            h4(textOutput("HFpeak1")),
            h4(textOutput("LFpeak1")),
            h4(textOutput("HFcohMax1")),
            h4(textOutput("LFcohMax1"))
            #br(),
              ), column(4,
                        h4("Closed-Loop Transfer Function with 0-delay effects:"),
            wellPanel(style = "background:white",
                      plotOutput("yesDEL")),
            h4(textOutput("HF2")),
            h4(textOutput("LF2")), 
            h4(textOutput("HFpeak2")),
            h4(textOutput("LFpeak2")),
            h4(textOutput("HFcohMax2")),
            h4(textOutput("LFcohMax2"))
            #br(),
              ), column(4,
                        h4("Open-Loop Transfer Function:"),
            wellPanel(style = "background:white",
                      plotOutput("open")),
            h4(textOutput("HF3")),
            h4(textOutput("LF3")),
            h4(textOutput("HFpeak3")),
            h4(textOutput("LFpeak3")),
            h4(textOutput("HFcohMax3")),
            h4(textOutput("LFcohMax3"))
              ))
  ),
  wellPanel(
    fluidRow(
      column(6, h4("Comparison of Gains:"),
             wellPanel(style = "background:white",
                       plotOutput("barplot"))),
      column(6,  h4("LF/HF ratio of Gains:"),
             wellPanel(style = "background:white",
                       plotOutput("barplot2")))
    )
  ), 
  wellPanel(
    h3("Estimated 0-lag effects:"),
    tags$hr(),
    wellPanel(style = "background:white",
              plotOutput("barplot3")),
    h4(textOutput("estimated_a0"))
  ),
  wellPanel(
    fluidRow(column(12,
                    wellPanel(style = "height:850px;background:white",
                              imageOutput("BDiagram"))
    )
    ),
    h3("Block transfer functions (without 0-lag effects):"),
    tags$hr(),
    fluidRow(
      column(6, h4("Output autoregulation:"),
             wellPanel(style = "background:white",
             plotOutput("block1_noA0"))),
      column(6, h4("Influence of input over output:"),
             wellPanel(style = "background:white",
             plotOutput("block2_noA0")))
    ),
    br(),
    h3("Block transfer functions (with 0-lag effects):"),
    tags$hr(),
    fluidRow(
      column(6, h4("Output autoregulation:"),
             wellPanel(style = "background:white",
                       plotOutput("block1_A0"))),
      column(6, h4("Influence of input over output:"),
             wellPanel(style = "background:white",
                       plotOutput("block2_A0")))
    )
    
  ),
  wellPanel(
    fluidRow(column(12,
                    wellPanel(style = "height:850px;background:white",
                              imageOutput("NDiagram"))
    )
    ),
    br(),
    h3("Noise transfer functions (without 0-lag effects):"),
    tags$hr(),
    fluidRow(
      column(6,  h4("Transfer of Output Noise to Output:"),
             wellPanel(style = "background:white",
                       plotOutput("noise1_noA0"))),
      column(6, h4("Transfer of Input Noise to Output:"),
             wellPanel(style = "background:white",
                       plotOutput("noise2_noA0")))
    ),
    br(),
    h3("Noise transfer functions (with 0-lag effects):"),
    tags$hr(),
    fluidRow(
      column(6, h4("Transfer of Output Noise to Output:"),
             wellPanel(style = "background:white",
                       plotOutput("noise1_A0"))),
      column(6, h4("Transfer of Input Noise to Output:"),
             wellPanel(style = "background:white",
                       plotOutput("noise2_A0")))
    )
  ),
  wellPanel(
    h3("Noise contributions for RR PSD:"),
    tags$hr(),
    fluidRow(
      column(12,
             wellPanel(style = "background:white",
                       plotOutput("noiseCon1")))
    ),
    br(),
    h3("Noise contributions for SBP PSD:"),
    tags$hr(),
    fluidRow(
      column(12,
             wellPanel(style = "background:white",
                       plotOutput("noiseCon2")))
  ),
  br(),
  h3("Causal flow:"),
  tags$hr(),
  fluidRow(
    column(12,
           wellPanel(style = "background:white",
                     plotOutput("causal")))
  ),
  h4(textOutput("CausalCoh_HF")),
  h4(textOutput("CausalCoh_LF")),
  br(),
  fluidRow(
    column(12,
           wellPanel(style = "background:white",
                     plotOutput("causal2")))
  )),
  wellPanel(
            fluidRow(
              column(4, 
                                  numericInput("RRnoiseVar", "RR noise variance:", 0),
                     h4(textOutput("RRnoiseVarT"))),
              column(4, 
                     numericInput("SBPnoiseVar", "SBP noise variance:", 0),
                     h4(textOutput("SBPnoiseVarT"))),
              column(4, 
                     numericInput("A0_effect", "A0 effect:", 0),
                     h4(textOutput("estimated_a0_2")))
              
            ),
            fluidRow(
              column(6,
                     h5("RR PSD"),
                     wellPanel(style = "background:white",
                               plotOutput("psd1"))),
              column(6,
                     h5("SBP PSD"),
                     wellPanel(style = "background:white",
                               plotOutput("psd2")))
            ),
            actionButton("simulate", "Calculate Simulation")
            ),
  wellPanel(
    h3("PSDs from individual AR(p) models:"),
    tags$hr(),
    fluidRow(
      column(6,
             h4("RR PSD:"),
             wellPanel(style = "background:white",
                       plotOutput("ar1")),
             h4(textOutput("arHF1")),
             h4(textOutput("arHFpeak1")),
             h4(textOutput("arLF1")),
             h4(textOutput("arLFpeak1"))),
      column(6,
             h4("SBP PSD:"),
             wellPanel(style = "background:white",
                       plotOutput("ar2")),
             h4(textOutput("arHF2")),
             h4(textOutput("arHFpeak2")),
             h4(textOutput("arLF2")),
             h4(textOutput("arLFpeak2")))
    )),

    
  
)


# Server of the program
server <- function(input, output, session) {
  options(shiny.maxRequestSize = 100*1024^2) # To change default size for uploaded data
  output$data_file <- renderUI({
    fileInput("data_file", "Upload data file",
              multiple = FALSE, accept = c("text/csv",
                                          "text/comma-separated-values", "text/plain",
                                          ".csv", ".txt"))
  })
  Data <- reactiveValues()
  Data$List <- list()
  Data$List2 <- list()
  Data$Form <- list()
  Data$Structure <- list()
  Data$Validity <- FALSE
  
  
  timesegment <- "Time segment: no time segment has been chosen"
  stationarity <- "Stationarity:"
  model <- "Best Model:"
  model2 <- "Estimated Model:"
  whitenoise <- "Residuals:"
  stable <- "Stability:"
  validity <- "Evaluation:"
  output$text_timesegment <- renderText({timesegment})
  output$text_stationary <- renderText({stationarity})
  output$text_model <- renderText({model})
  output$text_model2 <- renderText({model2})
  output$text_whitenoise <- renderText({whitenoise})
  output$text_stable <- renderText({stable})
  output$text_validity <- renderText({validity})
  
  observeEvent(input$upload, {
    req(input$data_file)
    data <- read.csv(input$data_file$datapath,
                     header = TRUE, sep = input$separator,
                     quote  ="")
    #data <- PreprocessData(data, use.RHRV = TRUE)
    R_data <- data
    if(input$Interpolate) data <- InterpolateData(data, input$int_freq)
    List <- isolate(Data$List)
    Time <- data[[1]]
    SBP <- data$SBP
    DBP <- data$DBP
    RR <- data$RR
    N <- NROW(Time)
    #for(n in 2:N) if(Time[n]<Time[n-1]) break
    #if(!is.null(n)) Time[n:N] <- Time[n:N]*60
    #for(m in 1:N) if(SBP[m] > 300 | SBP[m] < 30) Time[m] <- NA
    #SBP <- SBP[!is.na(Time)]
    #DBP <- DBP[!is.na(Time)]
    #Time <- Time[!is.na(Time)]
    #N <- NROW(Time)
    #for(m in 1:N) if(DBP[m] > 300 | DBP[m] < 30) Time[m] <- NA
    #SBP <- SBP[!is.na(Time)]
    #DBP <- DBP[!is.na(Time)]
    #Time <- Time[!is.na(Time)]
    #N <- NROW(Time)
    #RR <- double(N)
    #RR[2:N] <- diff(Time * 1000)
    #RR[1] <- RR[2]
    #HR <- 60000 / RR
    #for(m in 1:N) if(HR[m] > 200 | HR[m] < 25) Time[m] <- NA
    #RR <- RR[!is.na(Time)]
    #SBP <- SBP[!is.na(Time)]
    #DBP <- DBP[!is.na(Time)]
    #Time <- Time[!is.na(Time)]
    saveData <- list(Time = Time, RR = RR, SBP = SBP, DBP = DBP)
    #if(input$Interpolate) saveData <- InterpolateData(saveData)
    Data$List <- saveData
    saveData$HR <- 60000 / saveData$RR
    output$Raw <- renderPlot({
      ggplot2::ggplot(data = data.frame(saveData), ggplot2::aes(Time)) +
        ggplot2::geom_line(ggplot2::aes(y = HR, colour = "HR")) + ggplot2::geom_line(ggplot2::aes(y = SBP, colour = "SBP")) +
        #ggplot2::geom_line(ggplot2::aes(y = DBP, colour = "DBP")) +
        ggplot2::theme(axis.title.y = ggplot2::element_blank())
    })
    output$data_file <- renderUI({
      fileInput("data_file", "Upload data file",
                multiple = FALSE, accept = c("text/csv",
                                            "text/comma-separated-values", "text/plain",
                                            ".csv", ".txt"))
    })
    #Data$List <- R_data
  })
  
  output$hr_stats <- renderText({
    check_brush <- !is.null(input$brush_raw)
    if(check_brush){
      data <- isolate(Data$List)
      #data <- PreprocessData2(data)
      #data <- InterpolateData(data, 4)
      select_time <- (data$Time >= input$brush_raw$xmin & data$Time <= input$brush_raw$xmax)
      select_time <- c(1:NROW(data$Time))[select_time]
      RR <- data$RR[select_time]
      HR <- 60000/RR
      text <- paste("Heart Rate: ", round(mean(HR),3), " bpm (SD ", round(sd(HR),3), " bpm)", sep = "")
      return(text)
    }
  })
  output$sbp_stats <- renderText({
    check_brush <- !is.null(input$brush_raw)
    if(check_brush){
      data <- isolate(Data$List)
      #data <- PreprocessData2(data)
      #data <- InterpolateData(data, 4)
      select_time <- (data$Time >= input$brush_raw$xmin & data$Time <= input$brush_raw$xmax)
      select_time <- c(1:NROW(data$Time))[select_time]
      SBP <- data$SBP[select_time]
      text <- paste("Systolic Blood Pressure: ", round(mean(SBP),3), " mmHg (SD ", round(sd(SBP),3), " mmHg)", sep = "")
      return(text)
    }
    })

  
  output$text_timesegment <- renderText({
    check_brush <- !is.null(input$brush_raw)
    if(check_brush){
      data <- isolate(Data$List)
    #timesegment <- paste("Time segment: from", round(input$brush_raw$xmin/60, 3), "to", round(input$brush_raw$xmax/60, 3), "min")
      minT <- min(data$Time)
      maxT <- max(data$Time)
      t1 <- input$brush_raw$xmin
      t2 <- input$brush_raw$xmax
      if(t1 <= minT) t1 <- minT
      if(t2 >= maxT) t2 <- maxT
      timesegment <- paste("Time segment: from", t1 %/% 60, "min", round(t1 %% 60, 3) , " sec to",
                           t2 %/% 60, "min", round(t2 %% 60, 3), "sec.")
    }
  return(timesegment)})
  
  output$text_stationary <- renderText({
    check_brush <- !is.null(input$brush_raw)
    if(check_brush){
    data <- isolate(Data$List)
    #data <- PreprocessData2(data)
    #data <- InterpolateData(data, 4)
    data_validity <- isolate(Data$Validity)
    select_time <- (data$Time >= input$brush_raw$xmin & data$Time <= input$brush_raw$xmax)
    select_time <- c(1:NROW(data$Time))[select_time]
    RR <- data$RR[select_time] - mean(data$RR[select_time])
    SBP <- data$SBP[select_time] - mean(data$SBP[select_time])
    #RR <- DetrendByCutoff(data$RR[select_time], cutoff = 0.25, max_f = 3.3, f = input$int_freq)
    #SBP <- DetrendByCutoff(data$SBP[select_time], cutoff = 0.25, max_f = 3.3, f = input$int_freq)
    #DBP <- DetrendByCutoff(data$DBP[select_time])
    #RR <- DetrendVLF(data$RR[select_time])$detrend
    #SBP <- DetrendVLF(data$SBP[select_time])$detrend
    #DBP <- DetrendVLF(data$DBP[select_time])$detrend
    #SBP <- data$SBP[select_time]
    #RR <- data$RR[select_time]
    Time <- data$Time[select_time]
    stationarity <- CheckStationarity(cbind(SBP = SBP, RR = RR), warnings = FALSE, verbose = FALSE)
    if(!stationarity){
      RR <- DetrendByCutoff(data$RR[select_time], cutoff = 0.25, max_f = 3.3, f = input$int_freq)
      SBP <- DetrendByCutoff(data$SBP[select_time], cutoff = 0.25, max_f = 3.3, f = input$int_freq)
      data <- cbind(SBP = SBP, RR = RR)
      stationarity <- CheckStationarity(data, warnings = FALSE, verbose = FALSE)
    }
    #stationarity <- TRUE ###CHECK!!!
    stationarity <- ifelse(stationarity, "Stationarity: The segment is stationary", "Stationarity: The segment is not stationary")
    return(stationarity)
    }})
  
  output$text_model <- renderText({
    check_brush <- !is.null(input$brush_raw)
    if(check_brush){
      data <- isolate(Data$List)
      #data <- PreprocessData2(data)
      #data <- InterpolateData(data, 4)
      data_validity <- isolate(Data$Validity)
      select_time <- (data$Time >= input$brush_raw$xmin & data$Time <= input$brush_raw$xmax)
      select_time <- c(1:NROW(data$Time))[select_time]
      RR <- data$RR[select_time] - mean(data$RR[select_time])
      SBP <- data$SBP[select_time] - mean(data$SBP[select_time])
      #RR <- DetrendByCutoff(data$RR[select_time], cutoff = 0.25, max_f = 3.3, f = input$int_freq)
      #SBP <- DetrendByCutoff(data$SBP[select_time], cutoff = 0.25, max_f = 3.3, f = input$int_freq)
      #DBP <- DetrendByCutoff(data$DBP[select_time])
      #RR <- DetrendVLF(data$RR[select_time])$detrend
      #SBP <- DetrendVLF(data$SBP[select_time])$detrend
      #DBP <- DetrendVLF(data$DBP[select_time])$detrend
      #SBP <- data$SBP[select_time]
      #RR <- data$RR[select_time]
      Time <- data$Time[select_time]
      stationarity <- CheckStationarity(cbind(SBP = SBP, RR = RR), warnings = FALSE, verbose = FALSE)
      #stationarity <- TRUE #CHECK!!!!!!!
      if(stationarity){
        data <- cbind(SBP = SBP, RR = RR)
        model <- EstimateVAR(data)
        model <- paste("Model according to AIC: VAR(", model$p, ")", sep = "")
      } else {
        RR <- DetrendByCutoff(data$RR[select_time], cutoff = 0.25, max_f = 3.3, f = input$int_freq)
        SBP <- DetrendByCutoff(data$SBP[select_time], cutoff = 0.25, max_f = 3.3, f = input$int_freq)
        data <- cbind(SBP = SBP, RR = RR)
        stationarity <- CheckStationarity(data, warnings = FALSE, verbose = FALSE)
        if(stationarity){
          model <- EstimateVAR(data)
          model <- paste("Model according to AIC: VAR(", model$p, ")", sep = "")
        } else {
          model <- "Model according to AIC: cannot be estimated as the time segment is not stationary"
        }
       
      }
      return(model)
    }})
  
  output$text_model2 <- renderText({
    check_brush <- !is.null(input$brush_raw)
    if(check_brush){
      data <- isolate(Data$List)
      #data <- PreprocessData2(data)
      #data <- InterpolateData(data, 4)
      data_validity <- isolate(Data$Validity)
      select_time <- (data$Time >= input$brush_raw$xmin & data$Time <= input$brush_raw$xmax)
      select_time <- c(1:NROW(data$Time))[select_time]
      RR <- data$RR[select_time] - mean(data$RR[select_time])
      SBP <- data$SBP[select_time] - mean(data$SBP[select_time])
      #RR <- DetrendByCutoff(data$RR[select_time], cutoff = 0.25, max_f = 3.3, f = input$int_freq)
      #SBP <- DetrendByCutoff(data$SBP[select_time], cutoff = 0.25, max_f = 3.3, f = input$int_freq)
      #DBP <- DetrendByCutoff(data$DBP[select_time])
      #RR <- DetrendVLF(data$RR[select_time])$detrend
      #SBP <- DetrendVLF(data$SBP[select_time])$detrend
      #DBP <- DetrendVLF(data$DBP[select_time])$detrend
      #SBP <- data$SBP[select_time]
      #RR <- data$RR[select_time]
      Time <- data$Time[select_time]
      stationarity <- CheckStationarity(cbind(SBP = SBP, RR = RR), warnings = FALSE, verbose = FALSE)
      #stationarity <- TRUE #CHECK!!!!!!!
      if(stationarity){
        data <- cbind(SBP = SBP, RR = RR)
        #model <- EstimateVAR(data)
        #if(input$Use_order) model <- EstimateVAR(data, p = input$order, pmax = NULL)
        model <- EstimateVAR(data, p = input$order, pmax = NULL)
        model <- paste("Estimated Model: VAR(", model$p, ")", sep = "")
      } else {
        RR <- DetrendByCutoff(data$RR[select_time], cutoff = 0.25, max_f = 3.3, f = input$int_freq)
        SBP <- DetrendByCutoff(data$SBP[select_time], cutoff = 0.25, max_f = 3.3, f = input$int_freq)
        data <- cbind(SBP = SBP, RR = RR)
        stationarity <- CheckStationarity(data, warnings = FALSE, verbose = FALSE)
        if(stationarity){
          #model <- EstimateVAR(data)
          #if(input$Use_order) model <- EstimateVAR(data, p = input$order, pmax = NULL)
          model <- EstimateVAR(data, p = input$order, pmax = NULL)
          model <- paste("Estimated Model: VAR(", model$p, ")", sep = "")
          }  else {
              model <- "Estimated Model: cannot be estimated as the time segment is not stationary"
            
          }
      }
      return(model)
    }})
  
  output$text_whitenoise <- renderText({
    check_brush <- !is.null(input$brush_raw)
    if(check_brush){
      data <- isolate(Data$List)
      #data <- PreprocessData2(data)
      #data <- InterpolateData(data, 4)
      data_validity <- isolate(Data$Validity)
      select_time <- (data$Time >= input$brush_raw$xmin & data$Time <= input$brush_raw$xmax)
      select_time <- c(1:NROW(data$Time))[select_time]
      RR <- data$RR[select_time] - mean(data$RR[select_time])
      SBP <- data$SBP[select_time] - mean(data$SBP[select_time])
      #RR <- DetrendByCutoff(data$RR[select_time], cutoff = 0.25, max_f = 3.3, f = input$int_freq)
      #SBP <- DetrendByCutoff(data$SBP[select_time], cutoff = 0.25, max_f = 3.3, f = input$int_freq)
      #DBP <- DetrendByCutoff(data$DBP[select_time])
      #RR <- DetrendVLF(data$RR[select_time])$detrend
      #SBP <- DetrendVLF(data$SBP[select_time])$detrend
      #DBP <- DetrendVLF(data$DBP[select_time])$detrend
      #SBP <- data$SBP[select_time]
      #RR <- data$RR[select_time]
      Time <- data$Time[select_time]
      stationarity <- CheckStationarity(cbind(SBP = SBP, RR = RR), warnings = FALSE, verbose = FALSE)
      #stationarity <- TRUE #CHECK!!!!!!!
      if(stationarity){
        data <- cbind(SBP = SBP, RR = RR)
        model <- EstimateVAR(data, p = input$order, pmax = NULL)
        whitenoise <- DiagnoseResiduals(model)
        whitenoise <- ifelse(whitenoise, "Residuals: model residuals are a white noise process", "Residuals: model residuals are not a white noise process")
      } else {
        RR <- DetrendByCutoff(data$RR[select_time], cutoff = 0.25, max_f = 3.3, f = input$int_freq)
        SBP <- DetrendByCutoff(data$SBP[select_time], cutoff = 0.25, max_f = 3.3, f = input$int_freq)
        data <- cbind(SBP = SBP, RR = RR)
        stationarity <- CheckStationarity(cbind(SBP = SBP, RR = RR), warnings = FALSE, verbose = FALSE)
        if(stationarity){
          data <- cbind(SBP = SBP, RR = RR)
          model <- EstimateVAR(data, p = input$order, pmax = NULL)
          whitenoise <- DiagnoseResiduals(model)
          whitenoise <- ifelse(whitenoise, "Residuals: model residuals are a white noise process", "Residuals: model residuals are not a white noise process")
        } else {
        whitenoise <- "Residuals: residuals cannot be evaluated as the segment is not stationary"
        }
      }
      return(whitenoise)
    }
  })
  
  output$text_stable <- renderText({
    check_brush <- !is.null(input$brush_raw)
    if(check_brush){
      data <- isolate(Data$List)
      #data <- PreprocessData2(data)
      #data <- InterpolateData(data, 4)
      data_validity <- isolate(Data$Validity)
      select_time <- (data$Time >= input$brush_raw$xmin & data$Time <= input$brush_raw$xmax)
      select_time <- c(1:NROW(data$Time))[select_time]
      RR <- data$RR[select_time] - mean(data$RR[select_time])
      SBP <- data$SBP[select_time] - mean(data$SBP[select_time])
      #RR <- DetrendByCutoff(data$RR[select_time], cutoff = 0.25, max_f = 3.3, f = input$int_freq)
      #SBP <- DetrendByCutoff(data$SBP[select_time], cutoff = 0.25, max_f = 3.3, f = input$int_freq)
      #DBP <- DetrendByCutoff(data$DBP[select_time])
      #RR <- DetrendVLF(data$RR[select_time])$detrend
      #SBP <- DetrendVLF(data$SBP[select_time])$detrend
      #DBP <- DetrendVLF(data$DBP[select_time])$detrend
      #SBP <- data$SBP[select_time]
      #RR <- data$RR[select_time]
      Time <- data$Time[select_time]
      stationarity <- CheckStationarity(cbind(SBP = SBP, RR = RR), warnings = FALSE, verbose = FALSE)
      #stationarity <- TRUE #CHECK!!!!!!!
      if(stationarity){
        data <- cbind(SBP = SBP, RR = RR)
        #model <- EstimateVAR(data)
        #if(input$Use_order) model <- EstimateVAR(data, p = input$order, pmax = NULL)
        model <- EstimateVAR(data, p = input$order, pmax = NULL)
        stability <- DiagnoseStability(model)
        stable <- ifelse(stability, "Stability: the model is stable", "Stability: the model is not stable")
      } else {
        RR <- DetrendByCutoff(data$RR[select_time], cutoff = 0.25, max_f = 3.3, f = input$int_freq)
        SBP <- DetrendByCutoff(data$SBP[select_time], cutoff = 0.25, max_f = 3.3, f = input$int_freq)
        data <- cbind(SBP = SBP, RR = RR)
        stationarity <- CheckStationarity(data, warnings = FALSE, verbose = FALSE)
        if(stationarity){
          #model <- EstimateVAR(data)
          #if(input$Use_order) model <- EstimateVAR(data, p = input$order, pmax = NULL)
          model <- EstimateVAR(data, p = input$order, pmax = NULL)
          stability <- DiagnoseStability(model)
          stable <- ifelse(stability, "Stability: the model is stable", "Stability: the model is not stable")
        }  else {
          stable <- "Stability: stability cannot be evaluated as the segment is not stationary"
        }
      }
      return(stable)
    }
  })
  
  output$text_validity <- renderText({
    check_brush <- !is.null(input$brush_raw)
    if(check_brush){
      data <- isolate(Data$List)
      #data <- PreprocessData2(data)
      #data <- InterpolateData(data, 4)
      data_validity <- isolate(Data$Validity)
      select_time <- (data$Time >= input$brush_raw$xmin & data$Time <= input$brush_raw$xmax)
      select_time <- c(1:NROW(data$Time))[select_time]
      RR <- data$RR[select_time] - mean(data$RR[select_time])
      SBP <- data$SBP[select_time] - mean(data$SBP[select_time])
      #RR <- DetrendByCutoff(data$RR[select_time], cutoff = 0.25, max_f = 3.3, f = input$int_freq)
      #SBP <- DetrendByCutoff(data$SBP[select_time], cutoff = 0.25, max_f = 3.3, f = input$int_freq)
      #DBP <- DetrendByCutoff(data$DBP[select_time])
      #RR <- DetrendVLF(data$RR[select_time])$detrend
      #SBP <- DetrendVLF(data$SBP[select_time])$detrend
      #DBP <- DetrendVLF(data$DBP[select_time])$detrend
      #SBP <- data$SBP[select_time]
      #RR <- data$RR[select_time]
      Time <- data$Time[select_time]
      stationarity <- CheckStationarity(cbind(SBP = SBP, RR = RR), warnings = FALSE, verbose = FALSE)
      #stationarity <- TRUE #CHECK!!!!!!!
      if(stationarity){
        data <- cbind(SBP = SBP, RR = RR)
        #model <- EstimateVAR(data)
        #if(input$Use_order) model <- EstimateVAR(data, p = input$order, pmax = NULL)
        model <- EstimateVAR(data, p = input$order, pmax = NULL)
        whitenoise <- DiagnoseResiduals(model)
        stability <- DiagnoseStability(model)
        validity <- ifelse(whitenoise & stability, "Model Evaluation: VALID", "Model Evaluation: NOT VALID")
        data_validity <- whitenoise & stability
      } else {
        RR <- DetrendByCutoff(data$RR[select_time], cutoff = 0.25, max_f = 3.3, f = input$int_freq)
        SBP <- DetrendByCutoff(data$SBP[select_time], cutoff = 0.25, max_f = 3.3, f = input$int_freq)
        data <- cbind(SBP = SBP, RR = RR)
        stationarity <- CheckStationarity(data, warnings = FALSE, verbose = FALSE)
        if(stationarity){
          #model <- EstimateVAR(data)
          #if(input$Use_order) model <- EstimateVAR(data, p = input$order, pmax = NULL)
          model <- EstimateVAR(data, p = input$order, pmax = NULL)
          whitenoise <- DiagnoseResiduals(model)
          stability <- DiagnoseStability(model)
          validity <- ifelse(whitenoise & stability, "Model Evaluation: VALID", "Model Evaluation: NOT VALID")
          data_validity <- whitenoise & stability
        }  else {
          validity <- "Model Evaluation: NOT VALID"
          data_validity <- FALSE
        }
      }
      Data$Validity <- data_validity
      return(validity)
    }
  })
  
  observeEvent(input$calculate, {
    check_brush <- !is.null(input$brush_raw)
    data_validity <- isolate(Data$Validity)
    Structure <- isolate(Data$Structure)
    if(check_brush & data_validity){
      data <- isolate(Data$List)
      form <- isolate(Data$Form)
      #data <- PreprocessData2(data)
      #data <- InterpolateData(data, 4)
      data2 <- isolate(Data$List2)
      select_time <- (data$Time >= input$brush_raw$xmin & data$Time <= input$brush_raw$xmax)
      form$"Start (min)" <- round(min(data$Time[select_time]/60),3)
      form$"End (min)" <- round(max(data$Time[select_time]/60),3)
      select_time <- c(1:NROW(data$Time))[select_time]
      RR <- data$RR[select_time] - mean(data$RR[select_time])
      SBP <- data$SBP[select_time] - mean(data$SBP[select_time])
      stationarity <- CheckStationarity(cbind(SBP = SBP, RR = RR), warnings = FALSE, verbose = FALSE)
      if(!stationarity){
        RR <- DetrendByCutoff(data$RR[select_time], cutoff = 0.25, max_f = 3.3, f = input$int_freq)
        SBP <- DetrendByCutoff(data$SBP[select_time], cutoff = 0.25, max_f = 3.3, f = input$int_freq)
      }
      #RR <- DetrendByCutoff(data$RR[select_time], cutoff = 0.25, max_f = 3.3, f = input$int_freq)
      #SBP <- DetrendByCutoff(data$SBP[select_time], cutoff = 0.25, max_f = 3.3, f = input$int_freq)
      #RR <- DetrendVLF(data$RR[select_time])
      #SBP <- DetrendVLF(data$SBP[select_time])
      #DBP <- DetrendByCutoff(data$DBP[select_time])
      #RR <- DetrendVLF(data$RR[select_time])$detrend
      #SBP <- DetrendVLF(data$SBP[select_time])$detrend
      #DBP <- DetrendVLF(data$DBP[select_time])$detrend
      #SBP <- data$SBP[select_time]
      #RR <- data$RR[select_time]
      Time <- data$Time[select_time]
      if(input$path_origin == "RR"){
        data <- cbind(RR = RR, SBP = SBP)
        names <- c("RR", "SBP")
        units <- c("ms", "mmHg")
      } else {
        data <- cbind(SBP = SBP, RR = RR)
        names <- c("SBP", "RR")
        units <- c("mmHg", "ms")
      }
      form$"VAR(p)" <- input$order
      model <- EstimateVAR(data, p = input$order, pmax = NULL)
      freq_model1 <- ParamFreqModel(model, A0 = FALSE, dt = 1/input$int_freq, len  =10000)
      freq_model2 <- ParamFreqModel(model, A0 = TRUE, dt = 1/input$int_freq, len = 10000)
      Structure <- freq_model2
      Structure$Signals <- data
      Structure$p <- input$order
      in_var <- match(input$input, names)
      out_var <- match(input$output, names)
      form$Input <- input$input
      form$Output <- input$output
      form$"Transfer Units" <- paste(units[out_var], "/", units[in_var], sep = "")
      form$"Coherence Threshold" <- input$coh_thr
      rr_pos <- match("RR", names)
      sbp_pos <- match("SBP", names)
      coherence <- CalculateCoherence(freq_model1, in_var, out_var)
      estimations1 <- GetExpectedValues(freq_model1, str = FALSE, coherence = coherence, 
                                        thr = input$coh_thr, use.coh = input$Use_coh, weight = !input$Use_coh,  VLF = 0.25, LF = 0.75, HF = 3.3)
      estimations2 <- GetExpectedValues(freq_model2, str = FALSE, coherence = coherence,
                                        thr = input$coh_thr, use.coh = input$Use_coh, weight = !input$Use_coh,  VLF = 0.25, LF = 0.75, HF = 3.3)
      est_form1 <- GetExpectedValues(freq_model2, str = FALSE, coherence = coherence,
                                        thr = input$coh_thr, use.coh = FALSE, VLF = 0.25, LF = 0.75, HF = 3.3, weight = TRUE)
      est_form2 <- GetExpectedValues(freq_model2, str = FALSE, coherence = coherence,
                                        thr = input$coh_thr, use.coh = TRUE, VLF = 0.25, LF = 0.75, HF = 3.3, weight = FALSE)
      peaks1 <- GetPeaks(freq_model1, str = FALSE)
      peaks2 <- GetPeaks(freq_model2, str = FALSE)
      peaks3 <- GetEstimateAtMaxCoh(freq_model1, str = FALSE, coherence = coherence, VLF = 0.25, LF = 0.75, HF = 3.3)
      peaks4 <- GetEstimateAtMaxCoh(freq_model2, str = FALSE, coherence = coherence, VLF = 0.25, LF = 0.75, HF = 3.3)
      output$CLDiagram <- renderImage({
        d1 <- tempfile(fileext = ".png")
        png(filename = d1, width = 1800, height = 700)
        if(in_var == rr_pos) PlotCLDiagram(1)
        if(in_var == sbp_pos) PlotCLDiagram(2)
        dev.off()
        return(list(src = d1, contentType = "image/png", width = 1800, height = 700, alt = "d1"))
      }, deleteFile = TRUE)
      output$BDiagram <- renderImage({
        d2 <- tempfile(fileext = ".png")
        png(filename = d2, width = 1800, height = 700)
        if(in_var == rr_pos) PlotBlockDiagram(1)
        if(in_var == sbp_pos) PlotBlockDiagram(2)
        dev.off()
        return(list(src = d2, contentType = "image/png", width = 1800, height = 700, alt = "d2"))
      }, deleteFile = TRUE)
      output$NDiagram <- renderImage({
        d3 <- tempfile(fileext = ".png")
        png(filename = d3, width = 1800, height = 700)
        if(out_var == rr_pos) PlotNoiseDiagram(1)
        if(out_var == sbp_pos) PlotNoiseDiagram(2)
        dev.off()
        return(list(src = d3, contentType = "image/png", width = 1800, height = 700, alt = "d3"))
      }, deleteFile = TRUE)
      output$coherence_plot <- renderPlot({PlotCoherence(freq_model1, out_var, in_var, coherence, thr = input$coh_thr, VLF = 0.25, LF = 0.75, HF = 3.3)})
      output$noDEL <- renderPlot({PlotTransferFun(freq_model1, out_var, in_var, VLF = 0.25, LF = 0.75, HF = 3.3)})
      output$yesDEL <- renderPlot({PlotTransferFun(freq_model2, out_var, in_var, VLF = 0.25, LF = 0.75, HF = 3.3)})
      output$open <- renderPlot({PlotTransferFun(freq_model1, out_var, in_var , open = TRUE, VLF = 0.25, LF = 0.75, HF = 3.3)})
      output$HF1 <- renderText({
        HF <- estimations1$HF$Transfer_Functions[out_var, in_var, 1]
        HF1 <- paste("Estimated transfer function at HF band: ", round(HF,3), " ", units[out_var], "/", units[in_var], sep = "")
        return(HF1)
      })
      output$HFpeak1 <- renderText({
        HF <- peaks1$HF$Transfer_Functions[out_var, in_var, 1]
        HF1 <- paste("Estimated HF modulation peak at", round(HF,3), "Hz ")
        return(HF1)
      })
      output$HFcohMax1 <- renderText({
        HF <- peaks3$HF$Transfer_Functions[out_var, in_var, 1]
        HF1 <- paste("Estimate at maximum squared coherence at HF band: ", round(HF,3), " ", units[out_var], "/", units[in_var], sep = "")
        return(HF1)
      })
      output$LF1 <- renderText({
        LF <- estimations1$LF$Transfer_Functions[out_var, in_var, 1]
        LF1 <- paste("Estimated transfer function at LF band: ", round(LF,3), " ", units[out_var], "/", units[in_var], sep = "")
        return(LF1)
      })
      output$LFpeak1 <- renderText({
        LF <- peaks1$LF$Transfer_Functions[out_var, in_var, 1]
        LF1 <- paste("Estimated LF modulation peak at", round(LF,3), "Hz ")
        return(LF1)
      })
      output$LFcohMax1 <- renderText({
        LF <- peaks3$LF$Transfer_Functions[out_var, in_var, 1]
        LF1 <- paste("Estimate at maximum squared coherence at LF band: ", round(LF,3), " ", units[out_var], "/", units[in_var], sep = "")
        return(LF1)
      })
      output$HF2 <- renderText({
        HF <- estimations2$HF$Transfer_Functions[out_var, in_var, 1]
        HF2 <- paste("Estimated transfer function at HF band: ", round(HF,3), " ", units[out_var], "/", units[in_var], sep = "")
        return(HF2)
      })
      form$"Transfer (HF):" <- round(est_form1$HF$Transfer_Functions[out_var, in_var, 1], 3)
      form$"Transfer (HF) with coherence threshold:" <- round(est_form2$HF$Transfer_Functions[out_var, in_var, 1], 3)
      output$HFpeak2 <- renderText({
        HF <- peaks2$HF$Transfer_Functions[out_var, in_var, 1]
        HF2 <- paste("Estimated HF modulation peak at", round(HF,3), "Hz ")
        return(HF2)
      })
      form$"Peak (HF, Hz):" <- round(peaks2$HF$Transfer_Functions[out_var, in_var, 1], 3)
      output$HFcohMax2 <- renderText({
        HF <- peaks4$HF$Transfer_Functions[out_var, in_var, 1]
        HF2 <- paste("Estimate at maximum squared coherence at HF band: ", round(HF,3), " ", units[out_var], "/", units[in_var], sep = "")
        return(HF2)
      })
      form$"Transfer at max coh (HF):" <- round(peaks4$HF$Transfer_Functions[out_var, in_var, 1], 3)
      output$LF2 <- renderText({
        LF <- estimations2$LF$Transfer_Functions[out_var, in_var, 1]
        LF2 <- paste("Estimated transfer function at LF band: ", round(LF,3), " ", units[out_var], "/", units[in_var], sep = "")
        return(LF2)
      })
      form$"Transfer (LF):" <- round(est_form1$LF$Transfer_Functions[out_var, in_var, 1], 3)
      form$"Transfer (LF) with coherence threshold:" <- round(est_form2$LF$Transfer_Functions[out_var, in_var, 1], 3)
      output$LFpeak2 <- renderText({
        LF <- peaks2$LF$Transfer_Functions[out_var, in_var, 1]
        LF2 <- paste("Estimated LF modulation peak at", round(LF,3), "Hz ")
        return(LF2)
      })
      form$"Peak (LF, Hz):" <- round(peaks2$LF$Transfer_Functions[out_var, in_var, 1], 3)
      output$LFcohMax2 <- renderText({
        LF <- peaks4$LF$Transfer_Functions[out_var, in_var, 1]
        LF2 <- paste("Estimate at maximum squared coherence at LF band: ", round(LF,3), " ", units[out_var], "/", units[in_var], sep = "")
        return(LF2)
      })
      form$"Transfer at max coh (LF):" <- round(peaks4$LF$Transfer_Functions[out_var, in_var, 1], 3)
      output$HF3 <- renderText({
        HF <- estimations1$HF$Open_Transfer_Functions[out_var, in_var, 1]
        HF3 <- paste("Estimated transfer function at HF band: ", round(HF,3), " ", units[out_var], "/", units[in_var], sep = "")
        return(HF3)
      })
      output$HFpeak3 <- renderText({
        HF <- peaks1$HF$Open_Transfer_Functions[out_var, in_var, 1]
        HF3 <- paste("Estimated HF modulation peak at", round(HF,3), "Hz ")
        return(HF3)
      })
      output$HFcohMax3 <- renderText({
        HF <- peaks3$HF$Open_Transfer_Functions[out_var, in_var, 1]
        HF3 <- paste("Estimate at maximum squared coherence at HF band: ", round(HF,3), " ", units[out_var], "/", units[in_var], sep = "")
        return(HF3)
      })
      output$LF3 <- renderText({
        LF <- estimations1$LF$Open_Transfer_Functions[out_var, in_var, 1]
        LF3 <- paste("Estimated transfer function at LF band: ", round(LF,3), " ", units[out_var], "/", units[in_var], sep = "")
        return(LF3)
      })
      output$LFpeak3 <- renderText({
        LF <- peaks1$LF$Open_Transfer_Functions[out_var, in_var, 1]
        LF3 <- paste("Estimated LF modulation peak at", round(LF,3), "Hz ")
        return(LF3)
      })
      output$LFcohMax3 <- renderText({
        LF <- peaks3$LF$Open_Transfer_Functions[out_var, in_var, 1]
        LF3 <- paste("Estimate at maximum squared coherence at LF band: ", round(LF,3), " ", units[out_var], "/", units[in_var], sep = "")
        return(LF3)
      })
      output$barplot <- renderPlot({
        par(mar = c(5,4,4,8))
        barplot(cbind(
        HF = c(estimations1$HF$Transfer_Functions[out_var, in_var, 1],
               estimations2$HF$Transfer_Functions[out_var, in_var, 1],
               estimations1$HF$Open_Transfer_Functions[out_var, in_var, 1]),
        LF = c(estimations1$LF$Transfer_Functions[out_var, in_var, 1],
               estimations2$LF$Transfer_Functions[out_var, in_var, 1],
               estimations1$LF$Open_Transfer_Functions[out_var, in_var, 1])
      ), beside = TRUE, legend.text = c("Closed", "Closed (A0)", "Open"),
      args.legend = list(x = "topright", bty = "n", xpd = TRUE, inset = c(-0.456, 0)))})
      output$barplot2 <- renderPlot({
        par(mar = c(5,4,4,12))
        barplot(cbind(
        Ratio = c(estimations1$LF$Transfer_Functions[out_var, in_var, 1],
                  estimations2$LF$Transfer_Functions[out_var, in_var, 1],
                  estimations1$LF$Open_Transfer_Functions[out_var, in_var, 1])/
          c(estimations1$HF$Transfer_Functions[out_var, in_var, 1],
            estimations2$HF$Transfer_Functions[out_var, in_var, 1],
            estimations1$HF$Open_Transfer_Functions[out_var, in_var, 1]))
      , beside = TRUE, legend.text = c("Closed", "Closed (A0)", "Open"),
      args.legend = list(x = "topright", bty = "n", xpd = TRUE, inset = c(-0.7, 0)))
        abline(h = 1, col = "red")})
      output$barplot3 <- renderPlot({
        barplot(-(freq_model2$a0[out_var, in_var]),  width = 0.3, xlim = c(-0.2,0.7), col = "red")
      })
      form$lag0 <- -(freq_model2$a0[out_var, in_var])
      output$estimated_a0 <-  renderText({
        a0 <- freq_model2$a0[out_var, in_var]
        a0 <- paste("Estimated 0-lag effect: ", round(-a0,3), " ", units[out_var], "/", units[in_var], sep = "")
        return(a0)
      })
      output$estimated_a0_2 <-  renderText({
        a0 <- freq_model2$a0[out_var, in_var]
        a0 <- paste("Estimated 0-lag effect:", a0)
        return(a0)
      })
      output$block1_noA0 <- renderPlot({PlotBlockTransferFun(freq_model1, in_var, in_var, VLF = 0.25, LF = 0.75, HF = 3.3)})
      output$block2_noA0 <- renderPlot({PlotBlockTransferFun(freq_model1, out_var, in_var, VLF = 0.25, LF = 0.75, HF = 3.3)})
      output$block1_A0 <- renderPlot({PlotBlockTransferFun(freq_model2, in_var, in_var, VLF = 0.25, LF = 0.75, HF = 3.3)})
      output$block2_A0 <- renderPlot({PlotBlockTransferFun(freq_model2, out_var, in_var, VLF = 0.25, LF = 0.75, HF = 3.3)})
      output$noise1_noA0 <- renderPlot({PlotNoiseTransferFun(freq_model1, in_var, in_var, VLF = 0.25, LF = 0.75, HF = 3.3)})
      output$noise2_noA0 <- renderPlot({PlotNoiseTransferFun(freq_model1, out_var, in_var, VLF = 0.25, LF = 0.75, HF = 3.3)})
      output$noise1_A0 <- renderPlot({PlotNoiseTransferFun(freq_model2, in_var, in_var, VLF = 0.25, LF = 0.75, HF = 3.3)})
      output$noise2_A0 <- renderPlot({PlotNoiseTransferFun(freq_model2, out_var, in_var, VLF = 0.25, LF = 0.75, HF = 3.3)})
      nconRR1 <- NoiseContribution(freq_model2, rr_pos, rr_pos, coherence = coherence, 
                                   thr = input$coh_thr, use.coh = input$Use_coh, VLF = 0.25, LF = 0.75, HF = 3.3)
      nconRR2 <- NoiseContribution(freq_model2, rr_pos, sbp_pos, coherence = coherence, 
                                   thr = input$coh_thr, use.coh = input$Use_coh, VLF = 0.25, LF = 0.75, HF = 3.3)
      nconSBP1 <- NoiseContribution(freq_model2, sbp_pos, rr_pos, coherence = coherence, 
                                    thr = input$coh_thr, use.coh = input$Use_coh, VLF = 0.25, LF = 0.75, HF = 3.3)
      nconSBP2 <- NoiseContribution(freq_model2, sbp_pos, sbp_pos, coherence = coherence, 
                                    thr = input$coh_thr, use.coh = input$Use_coh, VLF = 0.25, LF = 0.75, HF = 3.3)
      output$noiseCon1 <- renderPlot({PlotNoiseContribution(nconRR1, nconRR2)})
      output$noiseCon2 <- renderPlot({PlotNoiseContribution(nconSBP1, nconSBP2)})
      CCoh <- CalculateCausalCoherence2(freq_model2)
      #output$causal <- renderPlot({PlotCausality(freq_model2, in_var)})
      output$causal <- renderPlot({PlotCausalCoherence(freq_model2, CCoh, VLF = 0.25, LF = 0.75, HF = 3.3)})
      output$causal2 <- renderPlot({PlotCausality(freq_model2, CCoh, in_var, VLF = 0.25, LF = 0.75, HF = 3.3)})
      est_coh <- GetMeanCoherence(freq_model2, CCoh, VLF = 0.25, LF = 0.75, HF = 3.3)
      max_est_coh <- GetMaxCoherence(freq_model2, CCoh, VLF = 0.25, LF = 0.75, HF = 3.3)
      output$CausalCoh_HF <- renderText({return(paste("Coherence from SBP to RR at HF (n.u.): ",round(est_coh$HF$C2, 3), " (maximum value: ",
                                                      round(max_est_coh$HF$C2, 3), 
                                                      ") .Coherence from RR to SBP at HF (n.u.): ",  round(est_coh$HF$C1, 3) , 
                                                      " (maximum value: ",round(max_est_coh$HF$C1, 3), ")", sep  =""))})
      output$CausalCoh_LF <- renderText({return(paste("Coherence from SBP to RR at LF (n.u.): ",round(est_coh$LF$C2, 3)," (maximum value: ",
                                                      round(max_est_coh$LF$C2, 3), 
                                                      ") .Coherence from RR to SBP at LF (n.u.): ",  round(est_coh$LF$C1, 3) , 
                                                      " (maximum value: ",round(max_est_coh$LF$C1, 3), ")", sep  =""))})
      form$"Coherence at HF (n.u.)" <- round(est_coh$HF$Cr, 3)
      form$"Coherence at LF (n.u.)" <- round(est_coh$LF$Cr, 3)
      form$"Coherence from SBP to RR at HF (n.u.)" <- round(est_coh$HF$C2, 3)
      form$"Coherence from SBP to RR at LF (n.u.)" <- round(est_coh$LF$C2, 3)
      form$"Coherence from RR to SBP at HF (n.u.)" <- round(est_coh$HF$C1, 3)
      form$"Coherence from RR to SBP at LF (n.u.)" <- round(est_coh$LF$C1, 3)
      form$"Maximum coherence at HF (n.u.)" <- round(max_est_coh$HF$Cr, 3)
      form$"Maximum coherence at LF (n.u.)" <- round(max_est_coh$LF$Cr, 3)
      form$"Maximum coherence from SBP to RR at HF (n.u.)" <- round(max_est_coh$HF$C2, 3)
      form$"Maximum coherence from SBP to RR at LF (n.u.)" <- round(max_est_coh$LF$C2, 3)
      form$"Maximum coherence from RR to SBP at HF (n.u.)" <- round(max_est_coh$HF$C1, 3)
      form$"Maximum xoherence from RR to SBP at LF (n.u.)" <- round(max_est_coh$LF$C1, 3)
      output$RRnoiseVarT <- renderText({return(paste("Estimated RR noise variance:", freq_model2$Noise_Spectra[rr_pos,rr_pos]))})
      output$SBPnoiseVarT <- renderText({return(paste("Estimated SBP noise variance:", freq_model2$Noise_Spectra[sbp_pos,sbp_pos]))})
      # Para a la version humano:
        #GBias <- EstimateGrangBias(data, out_var, VLF = 0.25, LF = 0.75, HF = 3.3, p = input$order, it = input$gc_it,
        #                                          use.coh = input$Use_coh, coherence = coherence, thr = input$coh_thr, dt = 1/input$int_freq)
      #} else { 
        GBias <- c(0,0)
      #}
      GC <- CausalSignificance(freq_model2, out_var, VLF = 0.25, LF = 0.75, HF = 3.3, p = input$order, n = NROW(RR), k = NROW(names),
                                      use.coh = input$Use_coh, coherence = coherence, thr = input$coh_thr, bias_LF = GBias[1], bias_HF = GBias[2], stats = TRUE)
      if(input$surrogates){
         distribution <- GenerateDistribution(model, p = input$order, K = input$gc_it)
         GCDist <- EstimateSurrGC(distribution, index = out_var, p = input$order, n = NROW(RR), k = NROW(names))
         GCpval_HF <- CalculatePvalFromSurrogates(GCDist[2,], GC[[2]][2]/(NROW(RR) - input$order))
         GCpval_LF <- CalculatePvalFromSurrogates(GCDist[1,], GC[[2]][1]/(NROW(RR) - input$order))
      output$HFcausal_sig <- renderText({return(paste("Significance for current branch interactions at HF band:",GCpval_HF))})
      output$LFcausal_sig <- renderText({return(paste("Significance for current branch interactions at LF band:",  GCpval_LF))})
      }
      #output$HFcausal_sig2 <- renderText({return(paste("Significance for current branch interactions at HF band (Chi sq-test):", CausalSig[[2]][2]))})
      #output$LFcausal_sig2 <- renderText({return(paste("Significance for current branch interactions at LF band (Chi sq-test):", CausalSig[[2]][1]))})
      Data$List2 <- freq_model2
      #if((input$SBPnoiseVar == 0) & (input$RRnoiseVar == 0) & (input$A0_effect == 0)){
        S <- SimulateWithModel(freq_model2, c(freq_model2$Noise_Spectra[sbp_pos,sbp_pos], freq_model2$Noise_Spectra[rr_pos,rr_pos]), 
                               freq_model2$a0[out_var, in_var], f = input$int_freq)
      #} else {
      #  S <- SimulateWithModel(freq_model2, c(input$SBPnoiseVar, input$RRnoiseVar), input$A0_effect, f = input$int_freq)
      #}
      output$psd1 <- renderPlot({
        PlotSimulatedS(freq_model2, S, 2, VLF = 0.25, LF = 0.75, HF = 3.3)
      })
      output$psd2 <- renderPlot({
        PlotSimulatedS(freq_model2, S, 1, VLF = 0.25, LF = 0.75, HF = 3.3)
      })
      output$ar1 <- renderPlot({PSD(RR, f = input$int_freq, p = input$order, VLF = 0.25, LF = 0.75, HF = 3.3)})
      output$ar2 <- renderPlot({PSD(SBP, f = input$int_freq, p = input$order, VLF = 0.25, LF = 0.75, HF = 3.3)})
      RR_PSD <- PSD(RR, f = input$int_freq, p = input$order, plot = FALSE, output = TRUE, VLF = 0.25, LF = 0.75, HF = 3.3)
      SBP_PSD <- PSD(SBP, f = input$int_freq, p = input$order, plot = FALSE, output = TRUE, VLF = 0.25, LF = 0.75, HF = 3.3)
      output$arHF1 <- renderText({ return(paste("HF:", round(RR_PSD[1],3), "n.u.")) })
      output$arHFpeak1 <- renderText({ return(paste("HF peak at", round(RR_PSD[3],3), "Hz")) })
      output$arLF1 <- renderText({ return(paste("LF:", round(RR_PSD[2],3), "n.u.")) })
      output$arLFpeak1 <- renderText({ return(paste("LF peak at", round(RR_PSD[4],3), "Hz")) })
      output$arHF2 <- renderText({ return(paste("HF:", round(SBP_PSD[1],3), "n.u.")) })
      output$arHFpeak2 <- renderText({ return(paste("HF peak at", round(SBP_PSD[3],3), "Hz")) })
      output$arLF2 <- renderText({ return(paste("LF:", round(SBP_PSD[2],3), "n.u.")) })
      output$arLFpeak2 <- renderText({ return(paste("LF peak at", round(SBP_PSD[4],3), "Hz")) })
      form$"IBI PSD (HF, n.u.)" <- round(RR_PSD[1],3)
      form$"IBI PSD peak (HF, Hz)" <- round(RR_PSD[3],3)
      form$"IBI PSD (LF, n.u.)" <- round(RR_PSD[2],3)
      form$"IBI PSD peak (LF, Hz)" <- round(RR_PSD[4],3)
      form$"SBP PSD (HF, n.u.)" <- round(SBP_PSD[1],3)
      form$"SBP PSD peak (HF, Hz)" <- round(SBP_PSD[3],3)
      form$"SBP PSD (LF, n.u.)" <- round(SBP_PSD[2],3)
      form$"SBP PSD peak (LF, Hz)" <- round(SBP_PSD[4],3)
      Data$Form <- form
      Data$Structure <- Structure
    }
    
    observeEvent(input$simulate, {
      data <- isolate(Data$List2)
      S <- SimulateWithModel(data, c(input$SBPnoiseVar, input$RRnoiseVar), input$A0_effect, f = input$int_freq)
      output$psd1 <- renderPlot({
        PlotSimulatedS(data, S, 2)
      })
      output$psd2 <- renderPlot({
        PlotSimulatedS(data, S, 1)
      })
    })
    
    
  })
  
  output$download <- 
    downloadHandler(
      filename = function(){
        paste(input$name, ".txt", sep = "")
      },
      content = function(file){
        data <- isolate(Data$Form)
        data <- t(data.frame(data))
        write.table(data, file  = file, sep = "\t", col.names = FALSE, quote = FALSE, dec = ".")
        }
    )
  
  output$download2 <- 
    downloadHandler(
      filename = function(){
        paste(input$name, ".RDS", sep = "")
      },
      content = function(file){
        data <- isolate(Data$Structure)
        saveRDS(data, file = file)
      }
    )
  
  
}

# Run the application 
shinyApp(ui = ui, server = server)
