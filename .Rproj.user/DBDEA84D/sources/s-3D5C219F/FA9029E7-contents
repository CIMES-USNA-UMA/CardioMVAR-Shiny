#
# This is a Shiny web application. You can run the application by clicking
# the 'Run App' button above.
#
# Find out more about building applications with Shiny here:
#
#    http://shiny.rstudio.com/
#

library(shiny)

# Define UI for application that draws a histogram
ui <- fluidPage(

  wellPanel(
    fluidRow(
      column(3,
             wellPanel(h2("Upload data"),
                       p("Upload and store data from a specific subject",
                         style="text-align:justify;color:black;background-color:grey80"),
                       
                       uiOutput("data_file"),
                       tags$hr(),
                       radioButtons("separator", "Choose separator", choices = c(Semicolon =";",
                                                                                 Comma = ",",
                                                                                 Tab ="\t"), selected = ";"),
                       tags$hr(),
                       actionButton("upload", "Confirm Upload")
                       
             )
             
      ),
      column(9,
             wellPanel(style = "background:white",
                       plotOutput("Raw", brush = "brush_raw", dblclick = "dbc_raw")
             ),
             br(),
             actionButton("replot", "Replot"),
             actionButton("confirm", "Confirm Filtering"),
             numericInput("thrUp", "Upper Threshold", 3, 0, step = 0.01, width = 100),
             numericInput("thrD", "Bottom Threshold", 3, 0, step = 0.02, width = 100)
      )
      
    )
  ),
  wellPanel(
    wellPanel(style = "background:white",
              plotOutput("Filt")
    ),
    downloadButton("download", "Download Filtered Data"),
    textInput("name", "Name:", width = 300)
  )
)

# Define server logic required to draw a histogram
server <- function(input, output) {
  PreprocessData <- function(data, maxSBP = 300, minSBP = 30,
                             minbpm = 25, maxbpm = 200, use.RHRV = TRUE){
    Time <- data[[1]]
    SBP <- data$SBP
    DBP <- data$DBP
    N <- NROW(Time)
    for(n in 2:N) if(Time[n]<Time[n-1]) break
    if(!is.null(n)) Time[n:N] <- Time[n:N]*60
    N <- NROW(Time)
    for(m in 1:N) if(SBP[m] > maxSBP | SBP[m] < minSBP) Time[m] <- NA
    SBP <- SBP[!is.na(Time)]
    DBP <- DBP[!is.na(Time)]
    Time <- Time[!is.na(Time)]
    if(use.RHRV){
      RHRV_object <- PrepareTachoForRHRV(Time)
      RHRV_object <- RHRV::BuildNIHR(RHRV_object)
      RHRV_object <- RHRV::FilterNIHR(RHRV_object)
      RR <- RHRV_object$Beat$RR
      SBP <- SBP[Time %in% RHRV_object$Beat$Time]
      DBP <- DBP[Time %in% RHRV_object$Beat$Time]
      Time <- RHRV_object$Beat$Time
    } else {
      N <- NROW(Time)
      RR <- double(N)
      RR[2:N] <- diff(Time * 1000)
      RR[1] <- RR[2]
      HR <- 60000 / RR
      for(m in 1:N) if(HR[m] > maxbpm | HR[m] < minbpm) Time[m] <- NA
      RR <- RR[!is.na(Time)]
      SBP <- SBP[!is.na(Time)]
      DBP <- DBP[!is.na(Time)]
      Time <- Time[!is.na(Time)]
    }
    return(list(Time = Time, RR = RR, SBP = SBP, DBP = DBP, PP = SBP - DBP, 
                MAP = (2*SBP - DBP)/3))
  }
  
  
  

  options(shiny.maxRequestSize = 100*1024^2) # To change default size for uploaded data
  output$data_file <- renderUI({
    fileInput("data_file", "Upload data file",
              multiple = FALSE, accept = c("text/csv",
                                           "text/comma-separated-values", "text/plain",
                                           ".csv", ".txt"))
  })
  Data <- reactiveValues()
  Data$List <- list()
  Data$List2 <- list()
  


  
  observeEvent(input$upload, {
    req(input$data_file)
    data <- read.csv(input$data_file$datapath,
                     header = TRUE, sep = input$separator,
                     quote  ="")
    data <- PreprocessData(data, use.RHRV = FALSE, maxbpm = 10000)
    R_data <- data
    List <- isolate(Data$List)
    Time <- data[[1]]
    SBP <- data$SBP
    DBP <- data$DBP
    RR <- data$RR
    N <- NROW(Time)
    saveData <- list(Time = Time, RR = RR, SBP = SBP, DBP = DBP)
    saveData$HR <- 60000 / saveData$RR
    saveData$Up <- mean(saveData$HR) + 3*sd(saveData$HR)
    saveData$Down <- mean(saveData$HR) - 3*sd(saveData$HR)
    output$Raw <- renderPlot({
      ggplot2::ggplot(data = data.frame(saveData), ggplot2::aes(Time)) +
        ggplot2::geom_line(ggplot2::aes(y = HR, colour = "HR")) + ggplot2::geom_line(ggplot2::aes(y = SBP, colour = "SBP")) +
        #ggplot2::geom_line(ggplot2::aes(y = DBP, colour = "DBP")) +
        ggplot2::theme(axis.title.y = ggplot2::element_blank()) +
        ggplot2::geom_hline(yintercept = mean(saveData$HR) + input$thrUp*sd(saveData$HR), colour = "brown") + ggplot2::geom_hline(yintercept = mean(saveData$HR) - input$thrD*sd(saveData$HR), colour = "brown")
    })
    output$data_file <- renderUI({
      fileInput("data_file", "Upload data file",
                multiple = FALSE, accept = c(
                                             ".csv", ".txt"))
    })
    Data$List <- saveData
  })


observeEvent(input$dbc_raw,{
  data <- isolate(Data$List)
  data2 <- isolate(Data$List2)
  HR <- data$HR
  select_time <- (data$Time >= input$brush_raw$xmin & data$Time <= input$brush_raw$xmax)
  select_time <- c(1:NROW(data$Time))[select_time]
  for(n in 1:5){
    data[[n]][select_time[(HR[select_time] > data$Up) | (HR[select_time] < data$Down)]] <- NA
     data[[n]] <- data[[n]][!is.na(data[[n]])]
  }
  data$Up <- mean(data$HR) + input$thrUp*sd(data$HR)
  data$Down <- mean(data$HR) - input$thrD*sd(data$HR)
  Data$List2 <- data
  output$Filt <- renderPlot({
    ggplot2::ggplot(data = data.frame(data), ggplot2::aes(Time)) +
      ggplot2::geom_line(ggplot2::aes(y = HR, colour = "HR")) + ggplot2::geom_line(ggplot2::aes(y = SBP, colour = "SBP")) +
      #ggplot2::geom_line(ggplot2::aes(y = DBP, colour = "DBP")) +
      ggplot2::theme(axis.title.y = ggplot2::element_blank()) 
  })
})

observeEvent(input$replot, {
  data2 <- isolate(Data$List)
  output$Raw <- renderPlot({
    ggplot2::ggplot(data = data.frame(data2), ggplot2::aes(Time)) +
      ggplot2::geom_line(ggplot2::aes(y = HR, colour = "HR")) + ggplot2::geom_line(ggplot2::aes(y = SBP, colour = "SBP")) +
      #ggplot2::geom_line(ggplot2::aes(y = DBP, colour = "DBP")) +
      ggplot2::theme(axis.title.y = ggplot2::element_blank()) +
      ggplot2::geom_hline(yintercept = mean(data2$HR) + input$thrUp*sd(data2$HR), colour = "brown") + 
      ggplot2::geom_hline(yintercept = mean(data2$HR) - input$thrD*sd(data2$HR), colour = "brown")
  })
})

observeEvent(input$confirm, {
  data <- isolate(Data$List)
  data2 <- isolate(Data$List2)
  Data$List <- data2
  output$Raw <- renderPlot({
    ggplot2::ggplot(data = data.frame(data2), ggplot2::aes(Time)) +
      ggplot2::geom_line(ggplot2::aes(y = HR, colour = "HR")) + ggplot2::geom_line(ggplot2::aes(y = SBP, colour = "SBP")) +
      #ggplot2::geom_line(ggplot2::aes(y = DBP, colour = "DBP")) +
      ggplot2::theme(axis.title.y = ggplot2::element_blank()) +
      ggplot2::geom_hline(yintercept = data2$Up, colour = "brown") + ggplot2::geom_hline(yintercept = data2$Down, colour = "brown")
  })
})

output$download <- 
  downloadHandler(
    filename = function(){
      paste(input$name, ".csv", sep = "")
    },
    content = function(file){
      data <- isolate(Data$List)
      data <- data.frame(data)
      data$Up <- data$Down <- NULL
      write.table(data, file  = file, sep = ";", row.names = FALSE, quote = FALSE, dec = ".")
    }
  )


}

# Run the application 
shinyApp(ui = ui, server = server)
